## 제네릭을 사용해야 하는 이유와 예 

**: 클래스나 메서드를 다양한 타입에서 사용할 수 있도록** 하는 자바의 기능입니다. 제네릭을 사용하면 **타입 매개변수**(Type Parameter)를 사용하여 **동일한 코드 구조에서 다양한 타입을 처리할 수 있습니다.**

예를 들어, `List<T>`는 `T`라는 타입 매개변수를 가지며, 이 `T`는 리스트에 저장될 객체의 타입을 지정합니다. 이를 통해 컴파일 시점에 타입 안전성을 보장할 수 있습니다.

### 제네릭 예

1. **제네릭을 사용하지 않은 예**
    
    ```java
    List list1 = new ArrayList<>();
    list1.add(100);        // Integer 타입
    list1.add("일이삼");    // String 타입
    
    // 값을 꺼낼 때 명시적인 캐스팅을 시도
    Integer num = (Integer) list1.get(0);  // 정상 작동
    Integer num2 = (Integer) list1.get(1); // 런타임 오류 발생
    ```
    
    - `list1`은 **제네릭 타입**을 사용하지 않고 선언되었습니다. 즉, **raw type**의 리스트입니다.
    - 제네릭을 명시하지 않으면 컴파일러가 타입 검사를 수행하지 않으므로, 다양한 타입의 객체를 리스트에 추가할 수 있습니다.
    - `list1.get(0);`을 `Integer`로 캐스팅할 때는 문제가 없지만,
    - `list1.get(1);`에서 `"일이삼"`은 **String** 타입이기 때문에, 이를 **Integer**로 캐스팅하려고 시도하는 순간 `ClassCastException`이 발생합니다.
2. **제네릭을 사용한 예**
    
    ```java
    List<Integer> list2 = new ArrayList<>();
    list2.add(100);        // Integer 타입
    // list2.add("일이삼");  // 컴파일 오류 발생, String 타입은 허용되지 않음
    
    // 값을 꺼낼 때 명시적 캐스팅이 불필요
    Integer num = list2.get(0);  // 정상 작동
    ```
    
    - `list2`는 **제네릭 타입**으로 선언되어 `Integer`만을 저장할 수 있는 리스트입니다.
    - 컴파일러가 타입을 검사하므로, `String`을 추가하려는 시도는 **컴파일 타임에 오류**로 잡힙니다.
    - 값을 꺼낼 때는 **명시적인 캐스팅이 필요 없고**, 타입 안전성이 보장되어 런타임 오류가 발생하지 않습니다.

### 제네릭을 사용해야 하는 이유

1. **타입 안전성**
: 제네릭을 사용하면 컴파일 타임에 타입을 검사할 수 있어, 잘못된 타입의 객체가 컬렉션에 저장되는 것을 방지할 수 있습니다. 이로 인해 런타임 오류가 줄어듭니다.
    - 예: `List<Integer> list = new ArrayList<>();`은 오직 `Integer`만 추가될 수 있습니다.
2. **코드의 재사용성**
: 제네릭을 사용하면 다양한 타입을 처리할 수 있는 코드 작성이 가능하여 코드의 재사용성이 높아집니다.
    - 예: `List<T>`는 `T` 타입만 다르게 지정하면 여러 타입의 리스트를 사용할 수 있습니다.
3. **캐스팅 제거**
: 제네릭을 사용하면 타입이 명확히 지정되기 때문에 객체를 꺼낼 때 **명시적인 캐스팅**이 필요 없습니다.
    - 예: `List<Integer> list = new ArrayList<>();` 에서 `list.get(0)`은 `Integer`로 자동으로 캐스팅됩니다.
4. **가독성 향상**
: 제네릭을 사용하면 개발자가 코드의 타입을 명확히 알 수 있어 가독성이 향상됩니다.
